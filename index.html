<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Happy Birthday Sara! ðŸŽ‰</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: linear-gradient(135deg, #0a0015 0%, #1a0033 50%, #0f001a 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            touch-action: none;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: block;
        }

        .stars {
            position: fixed;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }

        @keyframes twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.2); }
        }

        .message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-align: center;
            z-index: 10;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            animation: fadeIn 2s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @media (max-width: 768px) {
            .message {
                font-size: 12px;
                bottom: 10px;
                padding: 0 10px;
            }
        }

        @media (max-width: 480px) {
            .message {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="stars" id="stars"></div>
    <canvas id="c"></canvas>
    <div class="message">âœ¨ Tap to restart the celebration âœ¨</div>

    <script>
        // Create twinkling stars background
        const starsContainer = document.getElementById('stars');
        for (let i = 0; i < 50; i++) {
            const star = document.createElement('div');
            star.className = 'star';
            star.style.left = Math.random() * 100 + '%';
            star.style.top = Math.random() * 100 + '%';
            star.style.width = star.style.height = (Math.random() * 3 + 1) + 'px';
            star.style.animationDelay = Math.random() * 3 + 's';
            starsContainer.appendChild(star);
        }

        // Main animation
        const canvas = document.getElementById('c');
        const ctx = canvas.getContext('2d');
        
        let w, h, hw, hh;
        
        function resizeCanvas() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            hw = w / 2;
            hh = h / 2;
            
            // Responsive font size
            const baseSize = Math.min(w, h);
            opts.charSize = baseSize < 600 ? 20 : baseSize < 900 ? 25 : 30;
            opts.charSpacing = opts.charSize + 5;
            opts.lineHeight = opts.charSize + 15;
            
            ctx.font = `bold ${opts.charSize}px 'Segoe UI', Verdana, sans-serif`;
            
            // Recalculate letter positions
            calc.totalWidth = opts.charSpacing * Math.max(opts.strings[0].length, opts.strings[1].length, opts.strings[2].length);
        }

        const opts = {
            strings: ['HAPPY', 'BIRTHDAY!', 'MRS Sara'],
            charSize: 30,
            charSpacing: 35,
            lineHeight: 45,
            
            fireworkPrevPoints: 10,
            fireworkBaseLineWidth: 4,
            fireworkAddedLineWidth: 6,
            fireworkSpawnTime: 150,
            fireworkBaseReachTime: 25,
            fireworkAddedReachTime: 25,
            fireworkCircleBaseSize: 25,
            fireworkCircleAddedSize: 15,
            fireworkCircleBaseTime: 25,
            fireworkCircleAddedTime: 25,
            fireworkCircleFadeBaseTime: 10,
            fireworkCircleFadeAddedTime: 5,
            fireworkBaseShards: 5,
            fireworkAddedShards: 5,
            fireworkShardPrevPoints: 3,
            fireworkShardBaseVel: 3,
            fireworkShardAddedVel: 2,
            fireworkShardBaseSize: 3,
            fireworkShardAddedSize: 3,
            gravity: .08,
            upFlow: -.08,
            letterContemplatingWaitTime: 300,
            balloonSpawnTime: 15,
            balloonBaseInflateTime: 10,
            balloonAddedInflateTime: 10,
            balloonBaseSize: 18,
            balloonAddedSize: 18,
            balloonBaseVel: .3,
            balloonAddedVel: .3,
            balloonBaseRadian: -(Math.PI / 2 - .5),
            balloonAddedRadian: -1,
        };

        const calc = {
            totalWidth: 0
        };

        const Tau = Math.PI * 2;
        const TauQuarter = Tau / 4;
        const letters = [];

        resizeCanvas();

        function Letter(char, x, y) {
            this.char = char;
            this.x = x;
            this.y = y;
            
            this.dx = -ctx.measureText(char).width / 2;
            this.dy = +opts.charSize / 2;
            
            this.fireworkDy = this.y - hh;
            
            const hue = (x / calc.totalWidth * 360 + 180) % 360;
            
            this.color = `hsl(${hue}, 85%, 60%)`;
            this.lightAlphaColor = `hsla(${hue}, 85%, LIGHT%, ALP)`;
            this.lightColor = `hsl(${hue}, 85%, LIGHT%)`;
            this.alphaColor = `hsla(${hue}, 85%, 60%, ALP)`;
            
            this.reset();
        }

        Letter.prototype.reset = function() {
            this.phase = 'firework';
            this.tick = 0;
            this.spawned = false;
            this.spawningTime = Math.floor(opts.fireworkSpawnTime * Math.random());
            this.reachTime = Math.floor(opts.fireworkBaseReachTime + opts.fireworkAddedReachTime * Math.random());
            this.lineWidth = opts.fireworkBaseLineWidth + opts.fireworkAddedLineWidth * Math.random();
            this.prevPoints = [[0, hh, 0]];
        };

        Letter.prototype.step = function() {
            if (this.phase === 'firework') {
                if (!this.spawned) {
                    this.tick++;
                    if (this.tick >= this.spawningTime) {
                        this.tick = 0;
                        this.spawned = true;
                    }
                } else {
                    this.tick++;
                    
                    const linearProportion = this.tick / this.reachTime;
                    const armonicProportion = Math.sin(linearProportion * TauQuarter);
                    
                    const x = linearProportion * this.x;
                    const y = hh + armonicProportion * this.fireworkDy;
                    
                    if (this.prevPoints.length > opts.fireworkPrevPoints)
                        this.prevPoints.shift();
                    
                    this.prevPoints.push([x, y, linearProportion * this.lineWidth]);
                    
                    const lineWidthProportion = 1 / (this.prevPoints.length - 1);
                    
                    for (let i = 1; i < this.prevPoints.length; i++) {
                        const point = this.prevPoints[i];
                        const point2 = this.prevPoints[i - 1];
                        
                        ctx.strokeStyle = this.alphaColor.replace('ALP', i / this.prevPoints.length);
                        ctx.lineWidth = point[2] * lineWidthProportion * i;
                        ctx.beginPath();
                        ctx.moveTo(point[0], point[1]);
                        ctx.lineTo(point2[0], point2[1]);
                        ctx.stroke();
                        
                        // Add glow effect
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = this.color;
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    }
                    
                    if (this.tick >= this.reachTime) {
                        this.phase = 'contemplate';
                        
                        this.circleFinalSize = opts.fireworkCircleBaseSize + opts.fireworkCircleAddedSize * Math.random();
                        this.circleCompleteTime = Math.floor(opts.fireworkCircleBaseTime + opts.fireworkCircleAddedTime * Math.random());
                        this.circleCreating = true;
                        this.circleFading = false;
                        
                        this.circleFadeTime = Math.floor(opts.fireworkCircleFadeBaseTime + opts.fireworkCircleFadeAddedTime * Math.random());
                        this.tick = 0;
                        this.tick2 = 0;
                        
                        this.shards = [];
                        
                        const shardCount = Math.floor(opts.fireworkBaseShards + opts.fireworkAddedShards * Math.random());
                        const angle = Tau / shardCount;
                        const cos = Math.cos(angle);
                        const sin = Math.sin(angle);
                        
                        let x = 1, y = 0;
                        
                        for (let i = 0; i < shardCount; i++) {
                            const x1 = x;
                            x = x * cos - y * sin;
                            y = y * cos + x1 * sin;
                            
                            this.shards.push(new Shard(this.x, this.y, x, y, this.alphaColor, this.color));
                        }
                    }
                }
            } else if (this.phase === 'contemplate') {
                this.tick++;
                
                if (this.circleCreating) {
                    this.tick2++;
                    const proportion = this.tick2 / this.circleCompleteTime;
                    const armonic = -Math.cos(proportion * Math.PI) / 2 + .5;
                    
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = this.color;
                    ctx.fillStyle = this.lightAlphaColor.replace('LIGHT', 50 + 50 * proportion).replace('ALP', proportion);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, armonic * this.circleFinalSize, 0, Tau);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    if (this.tick2 > this.circleCompleteTime) {
                        this.tick2 = 0;
                        this.circleCreating = false;
                        this.circleFading = true;
                    }
                } else if (this.circleFading) {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                    ctx.fillStyle = this.lightColor.replace('LIGHT', 80);
                    ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                    ctx.shadowBlur = 0;
                    
                    this.tick2++;
                    const proportion = this.tick2 / this.circleFadeTime;
                    const armonic = -Math.cos(proportion * Math.PI) / 2 + .5;
                    
                    ctx.fillStyle = this.lightAlphaColor.replace('LIGHT', 100).replace('ALP', 1 - armonic);
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.circleFinalSize, 0, Tau);
                    ctx.fill();
                    
                    if (this.tick2 >= this.circleFadeTime)
                        this.circleFading = false;
                } else {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                    ctx.fillStyle = this.lightColor.replace('LIGHT', 80);
                    ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                    ctx.shadowBlur = 0;
                }
                
                for (let i = 0; i < this.shards.length; i++) {
                    this.shards[i].step();
                    
                    if (!this.shards[i].alive) {
                        this.shards.splice(i, 1);
                        i--;
                    }
                }
                
                if (this.tick > opts.letterContemplatingWaitTime) {
                    this.phase = 'balloon';
                    
                    this.tick = 0;
                    this.spawning = true;
                    this.spawnTime = Math.floor(opts.balloonSpawnTime * Math.random());
                    this.inflating = false;
                    this.inflateTime = Math.floor(opts.balloonBaseInflateTime + opts.balloonAddedInflateTime * Math.random());
                    this.size = Math.floor(opts.balloonBaseSize + opts.balloonAddedSize * Math.random());
                    
                    const rad = opts.balloonBaseRadian + opts.balloonAddedRadian * Math.random();
                    const vel = opts.balloonBaseVel + opts.balloonAddedVel * Math.random();
                    
                    this.vx = Math.cos(rad) * vel;
                    this.vy = Math.sin(rad) * vel;
                }
            } else if (this.phase === 'balloon') {
                ctx.strokeStyle = this.lightColor.replace('LIGHT', 85);
                ctx.lineWidth = 2;
                
                if (this.spawning) {
                    this.tick++;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                    ctx.fillStyle = this.lightColor.replace('LIGHT', 80);
                    ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                    ctx.shadowBlur = 0;
                    
                    if (this.tick >= this.spawnTime) {
                        this.tick = 0;
                        this.spawning = false;
                        this.inflating = true;
                    }
                } else if (this.inflating) {
                    this.tick++;
                    
                    const proportion = this.tick / this.inflateTime;
                    const x = this.cx = this.x;
                    const y = this.cy = this.y - this.size * proportion;
                    
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.color;
                    ctx.fillStyle = this.alphaColor.replace('ALP', proportion);
                    ctx.beginPath();
                    generateBalloonPath(x, y, this.size * proportion);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x, this.y);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                    ctx.fillStyle = this.lightColor.replace('LIGHT', 80);
                    ctx.fillText(this.char, this.x + this.dx, this.y + this.dy);
                    ctx.shadowBlur = 0;
                    
                    if (this.tick >= this.inflateTime) {
                        this.tick = 0;
                        this.inflating = false;
                    }
                } else {
                    this.cx += this.vx;
                    this.cy += this.vy += opts.upFlow;
                    
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.color;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    generateBalloonPath(this.cx, this.cy, this.size);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    
                    ctx.beginPath();
                    ctx.moveTo(this.cx, this.cy);
                    ctx.lineTo(this.cx, this.cy + this.size);
                    ctx.stroke();
                    
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                    ctx.fillStyle = this.lightColor.replace('LIGHT', 80);
                    ctx.fillText(this.char, this.cx + this.dx, this.cy + this.dy + this.size);
                    ctx.shadowBlur = 0;
                    
                    if (this.cy + this.size < -hh || this.cx < -hw || this.cx > hw)
                        this.phase = 'done';
                }
            }
        };

        function Shard(x, y, vx, vy, alphaColor, color) {
            const vel = opts.fireworkShardBaseVel + opts.fireworkShardAddedVel * Math.random();
            
            this.vx = vx * vel;
            this.vy = vy * vel;
            this.x = x;
            this.y = y;
            
            this.prevPoints = [[x, y]];
            this.alphaColor = alphaColor;
            this.color = color;
            this.alive = true;
            this.size = opts.fireworkShardBaseSize + opts.fireworkShardAddedSize * Math.random();
        }

        Shard.prototype.step = function() {
            this.x += this.vx;
            this.y += this.vy += opts.gravity;
            
            if (this.prevPoints.length > opts.fireworkShardPrevPoints)
                this.prevPoints.shift();
            
            this.prevPoints.push([this.x, this.y]);
            
            const lineWidthProportion = this.size / this.prevPoints.length;
            
            for (let k = 0; k < this.prevPoints.length - 1; k++) {
                const point = this.prevPoints[k];
                const point2 = this.prevPoints[k + 1];
                
                ctx.strokeStyle = this.alphaColor.replace('ALP', k / this.prevPoints.length);
                ctx.lineWidth = k * lineWidthProportion;
                ctx.beginPath();
                ctx.moveTo(point[0], point[1]);
                ctx.lineTo(point2[0], point2[1]);
                ctx.stroke();
                
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.stroke();
                ctx.shadowBlur = 0;
            }
            
            if (this.prevPoints[0][1] > hh)
                this.alive = false;
        };

        function generateBalloonPath(x, y, size) {
            ctx.moveTo(x, y);
            ctx.bezierCurveTo(x - size / 2, y - size / 2,
                             x - size / 4, y - size,
                             x, y - size);
            ctx.bezierCurveTo(x + size / 4, y - size,
                             x + size / 2, y - size / 2,
                             x, y);
        }

        function initLetters() {
            letters.length = 0;
            for (let i = 0; i < opts.strings.length; i++) {
                for (let j = 0; j < opts.strings[i].length; j++) {
                    letters.push(new Letter(
                        opts.strings[i][j],
                        j * opts.charSpacing + opts.charSpacing / 2 - opts.strings[i].length * opts.charSpacing / 2,
                        i * opts.lineHeight + opts.lineHeight / 2 - opts.strings.length * opts.lineHeight / 2
                    ));
                }
            }
        }

        function anim() {
            requestAnimationFrame(anim);
            
            ctx.fillStyle = 'rgba(10, 0, 21, 0.2)';
            ctx.fillRect(0, 0, w, h);
            
            ctx.save();
            ctx.translate(hw, hh);
            
            let done = true;
            for (let l = 0; l < letters.length; l++) {
                letters[l].step();
                if (letters[l].phase !== 'done')
                    done = false;
            }
            
            ctx.restore();
            
            if (done) {
                for (let l = 0; l < letters.length; l++)
                    letters[l].reset();
            }
        }

        initLetters();
        anim();

        window.addEventListener('resize', () => {
            resizeCanvas();
            initLetters();
        });

        // Touch to restart
        canvas.addEventListener('click', () => {
            for (let l = 0; l < letters.length; l++)
                letters[l].reset();
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            for (let l = 0; l < letters.length; l++)
                letters[l].reset();
        });
    </script>
</body>
</html>